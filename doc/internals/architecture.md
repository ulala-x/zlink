# zlink 시스템 아키텍처 - 내부 개발자 참조 문서

이 문서는 **zlink** 라이브러리의 내부 아키텍처를 상세히 기술합니다.
대상 독자는 zlink 라이브러리 자체를 개발하거나 유지보수하는 **내부 개발자**이며,
시스템의 계층 구조, 핵심 컴포넌트, 데이터 흐름, 소스 트리를 포괄적으로 다룹니다.

---

## 목차

1. [개요 및 설계 철학](#1-개요-및-설계-철학)
2. [5계층 아키텍처](#2-5계층-아키텍처)
3. [컴포넌트 연결 관계](#3-컴포넌트-연결-관계)
4. [Socket Logic Layer 상세](#4-socket-logic-layer-상세)
5. [Engine Layer 상세](#5-engine-layer-상세)
6. [핵심 컴포넌트](#6-핵심-컴포넌트)
7. [데이터 흐름](#7-데이터-흐름)
8. [소스 트리 구조](#8-소스-트리-구조)

---

## 1. 개요 및 설계 철학

### 1.1 zlink란?

zlink는 libzmq를 기반으로 한 고성능 메시징 라이브러리입니다.
기존 libzmq의 패턴과 API 호환성을 유지하면서 다음과 같은 현대적 설계를 적용했습니다:

- **Boost.Asio 기반 I/O**: 플랫폼별 폴러(epoll/kqueue/IOCP) 대신 Asio의 통합 비동기 I/O 사용
- **WebSocket/TLS 네이티브 지원**: `ws://`, `wss://`, `tls://` 프로토콜을 라이브러리 수준에서 내장
- **자체 프로토콜 스택**: ZMTP 대신 경량화된 **ZMP v2.0** 프로토콜 사용

### 1.2 설계 원칙

```
┌──────────────────────┬──────────────────────────────────────────────────────┐
│       원칙           │                       설명                           │
├──────────────────────┼──────────────────────────────────────────────────────┤
│  Zero-Copy           │  메시지 복사 최소화를 통한 메모리 대역폭 절약        │
│  Lock-Free           │  스레드 간 통신에 Lock-free 자료구조(YPipe) 사용     │
│  True Async          │  Proactor 패턴 기반의 진정한 비동기 I/O              │
│  Protocol Agnostic   │  트랜스포트와 프로토콜의 명확한 분리                  │
└──────────────────────┴──────────────────────────────────────────────────────┘
```

### 1.3 지원 소켓 및 트랜스포트

**소켓 패턴 (7종)**

| 소켓        | 유형             | 설명                              |
|-------------|------------------|-----------------------------------|
| PAIR        | 1:1 양방향       | 단일 연결, 양방향 통신            |
| PUB / SUB   | 발행-구독        | 토픽 기반 브로드캐스트            |
| XPUB / XSUB | 확장 발행-구독   | 구독 메시지 접근 가능             |
| DEALER      | 비동기 요청      | 라운드로빈 분배                   |
| ROUTER      | ID 기반 라우팅   | 다중 클라이언트 라우팅            |
| STREAM      | RAW TCP          | 외부 클라이언트 연동              |

**트랜스포트 (6종)**

| 스킴       | 설명                                      |
|------------|-------------------------------------------|
| `tcp://`   | 표준 TCP                                  |
| `ipc://`   | Unix 도메인 소켓 (Unix/Linux/macOS)       |
| `inproc://`| 프로세스 내 통신 (Lock-free 파이프)       |
| `ws://`    | WebSocket (Beast 라이브러리)              |
| `wss://`   | WebSocket over TLS                        |
| `tls://`   | 네이티브 TLS (OpenSSL)                    |

---

## 2. 5계층 아키텍처

zlink는 5개의 명확히 분리된 계층으로 구성됩니다.
각 계층은 단일 책임을 가지며, 아래로 갈수록 물리적 네트워크에 가까워집니다.

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          APPLICATION LAYER                              │
│                                                                         │
│   사용자 코드:                                                          │
│   zlink_ctx_new() -> zlink_socket() -> zlink_bind/connect()             │
│   -> zlink_send() / zlink_recv() -> zlink_close()                       │
│                                                                         │
├─────────────────────────────────────────────────────────────────────────┤
│                           PUBLIC API LAYER                              │
│                                                                         │
│   src/api/zlink.cpp                                                     │
│   - C API 진입점 (zlink_socket, zlink_send, zlink_recv 등)              │
│   - 에러 핸들링 및 파라미터 검증                                        │
│                                                                         │
├─────────────────────────────────────────────────────────────────────────┤
│                          SOCKET LOGIC LAYER                             │
│                                                                         │
│   src/sockets/                                                          │
│   - socket_base_t: 모든 소켓의 기반 클래스                              │
│   - pair_t, dealer_t, router_t, pub_t, sub_t, xpub_t, xsub_t, stream_t │
│   - 라우팅 전략: lb_t(RR), fq_t(Fair Queue), dist_t(Fan-out)           │
│   - 구독 관리: mtrie_t(XPUB), radix_tree_t / trie_with_size_t(XSUB)   │
│                                                                         │
├─────────────────────────────────────────────────────────────────────────┤
│                          ENGINE LAYER (ASIO)                            │
│                                                                         │
│   src/engine/asio/                                                      │
│   - asio_engine_t      : Proactor 패턴 기반 비동기 I/O 엔진 (기반)     │
│   - asio_zmp_engine_t  : ZMP 프로토콜 (8B 고정 헤더 + 핸드셰이크)      │
│   - asio_raw_engine_t  : RAW 프로토콜 (4B Length-Prefix, STREAM 전용)  │
│                                                                         │
├─────────────────────────────────────────────────────────────────────────┤
│                          PROTOCOL LAYER                                 │
│                                                                         │
│   ┌───────────────────────────┐    ┌───────────────────────────┐       │
│   │    ZMP v2.0 Protocol      │    │     RAW Protocol          │       │
│   │    src/protocol/zmp_*     │    │     src/protocol/raw_*    │       │
│   │    - 8바이트 고정 헤더     │    │     - 4바이트 길이 접두사  │       │
│   │    - 핸드셰이크 지원       │    │     - 핸드셰이크 없음      │       │
│   └───────────────────────────┘    └───────────────────────────┘       │
│                                                                         │
├─────────────────────────────────────────────────────────────────────────┤
│                          TRANSPORT LAYER                                │
│                                                                         │
│   src/transports/                                                       │
│   ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌──────────┐                 │
│   │   TCP   │  │   IPC   │  │   WS    │  │ TLS/WSS  │                 │
│   │  tcp_   │  │  ipc_   │  │  ws_    │  │  ssl_    │                 │
│   │transport│  │transport│  │transport│  │transport │                 │
│   └─────────┘  └─────────┘  └─────────┘  └──────────┘                 │
│                                                                         │
│   i_asio_transport: 모든 트랜스포트의 통합 비동기 인터페이스            │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

**계층 간 메시지 전달 경로**:
- 하향 (송신): Application -> API -> Socket Logic -> pipe_t -> Engine -> Protocol -> Transport
- 상향 (수신): Transport -> Protocol -> Engine -> pipe_t -> Socket Logic -> API -> Application

---

## 3. 컴포넌트 연결 관계

아래 다이어그램은 zlink 내부 객체들의 소유 관계와 상호작용을 보여줍니다.

```
┌──────────────────────────────────────────────────────────────────────┐
│                              ctx_t                                   │
│  (전역 컨텍스트: I/O 스레드풀, 소켓 관리, inproc 엔드포인트)         │
└────────────────────────────────┬─────────────────────────────────────┘
                                 │ owns
            ┌────────────────────┼────────────────────┐
            │                    │                    │
            v                    v                    v
    ┌───────────────┐   ┌───────────────┐   ┌───────────────┐
    │  socket_base_t│   │  io_thread_t  │   │   reaper_t    │
    │  (소켓 인스턴스)│   │ (I/O 워커)    │   │ (자원 정리)   │
    └───────┬───────┘   └───────┬───────┘   └───────────────┘
            │                   │
            │ owns              │ runs
            v                   v
    ┌───────────────┐   ┌───────────────┐
    │ session_base_t│   │  io_context   │
    │  (세션 관리)   │   │ (Asio 리액터) │
    └───────┬───────┘   └───────────────┘
            │
     ┌──────┴──────┐
     │             │
     v             v
┌─────────┐  ┌─────────────┐
│ pipe_t  │  │asio_engine_t│
│(메시지큐)│  │ (I/O 엔진)  │
└─────────┘  └──────┬──────┘
                    │
                    v
            ┌───────────────┐
            │i_asio_transport│
            │  (트랜스포트)  │
            └───────────────┘
```

**주요 소유 관계 설명**:

- `ctx_t`는 모든 `socket_base_t`, `io_thread_t`, `reaper_t`를 소유합니다.
- `socket_base_t`는 `session_base_t`를 소유하며, 세션은 소켓과 엔진 사이의 브리지 역할을 합니다.
- `session_base_t`는 `pipe_t`(Lock-free 메시지 큐)와 `asio_engine_t`(I/O 엔진)를 소유합니다.
- `asio_engine_t`는 `i_asio_transport` 인터페이스를 통해 물리적 전송 계층과 통신합니다.
- `io_thread_t`는 독립적인 `io_context`를 보유하여 비동기 I/O를 처리합니다.
- `reaper_t`는 종료된 소켓/세션의 자원을 안전하게 정리합니다.

---

## 4. Socket Logic Layer 상세

### 4.1 클래스 계층 구조

```
socket_base_t (기반 클래스)
├── pair_t              # PAIR 소켓: 1:1 양방향 통신
├── dealer_t            # DEALER 소켓: 비동기 요청, 라운드로빈
├── router_t            # ROUTER 소켓: ID 기반 라우팅 (routing_socket_base_t 상속)
├── xpub_t              # XPUB 소켓: 구독 메시지 수신 가능
│   └── pub_t           # PUB 소켓: XPUB 단순화 (구독 노출 없음)
├── xsub_t              # XSUB 소켓: 구독 메시지 송신 가능
│   └── sub_t           # SUB 소켓: XSUB 단순화 (setsockopt로 구독)
└── stream_t            # STREAM 소켓: RAW TCP, 외부 클라이언트 연동
```

`socket_base_t`는 모든 소켓의 공통 기능을 제공합니다:
- 연결 관리 (`bind`, `connect`, `disconnect`, `unbind`)
- 파이프 관리 (생성, 종료, 활성화)
- 옵션 관리 (`setsockopt`, `getsockopt`)
- 폴링 지원 (`has_in`, `has_out`)

### 4.2 라우팅 전략 클래스

소켓 타입별로 메시지 분배와 수집에 사용되는 전략 클래스가 분리되어 있습니다:

```
┌──────────────────────────────────────────────────────────────────────┐
│                     라우팅 전략 (Routing Strategies)                   │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  lb_t (Load Balancer) - 송신측 라운드로빈                     │    │
│  │                                                               │    │
│  │  Pipe A ──→ [ msg1 ]                                         │    │
│  │  Pipe B ──→ [ msg2 ]    ← 순서대로 돌아가며 분배             │    │
│  │  Pipe C ──→ [ msg3 ]                                         │    │
│  │                                                               │    │
│  │  사용 소켓: DEALER (송신)                                     │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  fq_t (Fair Queue) - 수신측 공정 큐                           │    │
│  │                                                               │    │
│  │  Pipe A ←── [ msg ]                                          │    │
│  │  Pipe B ←── [ msg ]    ← 각 파이프에서 공정하게 수신         │    │
│  │  Pipe C ←── [ msg ]                                          │    │
│  │                                                               │    │
│  │  사용 소켓: DEALER (수신), SUB (수신)                         │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  dist_t (Distributor) - 브로드캐스트 Fan-out                  │    │
│  │                                                               │    │
│  │  [ msg ] ──→ Pipe A                                          │    │
│  │          ──→ Pipe B    ← 동일 메시지를 모든 파이프에 전송     │    │
│  │          ──→ Pipe C                                          │    │
│  │                                                               │    │
│  │  사용 소켓: PUB, XPUB (송신)                                  │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

### 4.3 소켓별 라우팅 전략 매핑

| 소켓    | 송신 (Tx)             | 수신 (Rx)            | 비고                         |
|---------|-----------------------|----------------------|------------------------------|
| PAIR    | 단일 파이프            | 단일 파이프           | 파이프 1개만 허용            |
| DEALER  | `lb_t` (Round-robin)  | `fq_t` (Fair Queue)  | 비동기 요청-응답             |
| ROUTER  | ID 기반 직접 라우팅    | `fq_t` (Fair Queue)  | Routing ID로 대상 파이프 검색|
| PUB     | `dist_t` (Fan-out)    | -                    | 수신 불가                    |
| SUB     | -                     | `fq_t` (Fair Queue)  | 토픽 필터링 적용             |
| XPUB    | `dist_t` (Fan-out)    | 구독 메시지 수신      | mtrie_t로 구독 관리          |
| XSUB    | 구독 메시지 송신       | `fq_t` (Fair Queue)  | 필터링 + 구독 전송           |
| STREAM  | ID 기반 직접 라우팅    | `fq_t` (Fair Queue)  | RAW 프로토콜 사용            |

### 4.4 구독 자료구조

PUB/SUB 패턴에서 토픽 매칭에 사용되는 트라이 기반 자료구조:

```
┌─────────────────────────────────────────────────────────────┐
│                    구독 토픽 트라이 구조                      │
│                                                              │
│                       (root)                                 │
│                      /      \                                │
│                  "news"    "stock"                            │
│                   /          /   \                            │
│              "weather"   "AAPL"  "GOOGL"                     │
│                                                              │
│  - XPUB: mtrie_t (멀티 트라이, 파이프별 구독 추적)           │
│  - XSUB: ZLINK_USE_RADIX_TREE 매크로에 따라                  │
│    - radix_tree_t (활성화 시, 메모리 효율적)                 │
│    - trie_with_size_t (기본, 빠른 검색)                      │
│  - 검색 복잡도: O(m), m = 토픽 문자열 길이                   │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## 5. Engine Layer 상세

### 5.1 엔진 타입 비교

Engine Layer는 Boost.Asio 기반의 비동기 I/O 처리를 담당합니다.

| 엔진                  | 프로토콜  | 트랜스포트              | 특징                            |
|-----------------------|-----------|------------------------|---------------------------------|
| `asio_zmp_engine_t`   | ZMP v2.0  | TCP, TLS, IPC, WS, WSS | 핸드셰이크 + 8바이트 고정 헤더  |
| `asio_raw_engine_t`   | RAW       | TCP, TLS, IPC, WS, WSS | 4바이트 길이 접두사, STREAM 전용|

> WS/WSS도 `asio_zmp_engine_t` 또는 `asio_raw_engine_t`를 사용하며,
> WebSocket 프레이밍은 `ws_transport_t`/`wss_transport_t`가 처리합니다.

### 5.2 Proactor 패턴 구조

```
┌──────────────────────────────────────────────────────────────────┐
│                        asio_engine_t                             │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────┐         ┌──────────────────────────────┐  │
│  │ async_read_some │--------→│      on_read_complete        │  │
│  │   (비동기 읽기)  │         │  - 데이터 수신 완료 콜백       │  │
│  └─────────────────┘         │  - 디코더로 메시지 파싱        │  │
│                              │  - 세션으로 메시지 전달        │  │
│                              └──────────────────────────────┘  │
│                                                                  │
│  ┌─────────────────┐         ┌──────────────────────────────┐  │
│  │async_write_some │--------→│     on_write_complete        │  │
│  │   (비동기 쓰기)  │         │  - 데이터 송신 완료 콜백       │  │
│  └─────────────────┘         │  - 다음 메시지 인코딩          │  │
│                              │  - 더 보낼 데이터 있으면 반복   │  │
│                              └──────────────────────────────┘  │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                  Speculative I/O (최적화)                │   │
│  │                                                          │   │
│  │  speculative_read():                                     │   │
│  │    즉시 읽을 수 있는 데이터를 동기 방식으로 먼저 시도      │   │
│  │    -> 비동기 오버헤드 없이 처리량 향상                     │   │
│  │                                                          │   │
│  │  speculative_write():                                    │   │
│  │    즉시 쓸 수 있으면 동기 방식으로 쓰기                    │   │
│  │    -> 성공 시 콜백 없이 즉시 완료                         │   │
│  │    -> EAGAIN 시 async_write_some()으로 폴백              │   │
│  │                                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   Backpressure (배압)                    │   │
│  │                                                          │   │
│  │  _pending_buffers: 처리 못한 데이터 임시 저장             │   │
│  │  max_pending_buffer_size: 10MB 제한                      │   │
│  │  제한 초과 시 읽기 중단 -> 이후 여유 생기면 재개          │   │
│  │                                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

### 5.3 엔진 상태 머신

```
          ┌─────────────────────┐
          │    생성 (Created)    │
          └──────────┬──────────┘
                     │ plug()
                     v
          ┌─────────────────────┐
          │   핸드셰이크 중      │  TLS/WebSocket: 트랜스포트 핸드셰이크
          │  (_handshaking)     │  ZMP: 프로토콜 핸드셰이크
          └──────────┬──────────┘
                     │ handshake 완료
                     v
          ┌─────────────────────┐
          │    활성 (Active)    │ <-----------------┐
          │   데이터 송수신      │                   │
          └──────────┬──────────┘                   │
                     │ I/O 에러                      │ restart
                     v                              │
          ┌─────────────────────┐                   │
          │    에러 (Error)      │ -----------------┘
          └──────────┬──────────┘
                     │ terminate()
                     v
          ┌─────────────────────┐
          │   종료 (Terminated)  │
          └─────────────────────┘
```

### 5.4 ZMP v2.0 프레임 구조

```
 Byte:   0         1         2         3         4    5    6    7
      ┌─────────┬─────────┬─────────┬─────────┬─────────────────────┐
      │  MAGIC  │ VERSION │  FLAGS  │RESERVED │   PAYLOAD SIZE      │
      │  (0x5A) │  (0x02) │         │ (0x00)  │   (32-bit BE)       │
      └─────────┴─────────┴─────────┴─────────┴─────────────────────┘
```

| 필드         | 오프셋 | 크기 | 설명                    |
|-------------|--------|------|-------------------------|
| MAGIC       | 0      | 1    | 매직 넘버 `0x5A` ('Z')  |
| VERSION     | 1      | 1    | 프로토콜 버전 `0x02`    |
| FLAGS       | 2      | 1    | 프레임 플래그            |
| RESERVED    | 3      | 1    | 예약 (0x00)              |
| PAYLOAD SIZE| 4-7    | 4    | 페이로드 크기 (Big Endian)|

**FLAGS 비트 정의**:

| 비트 | 이름      | 설명               |
|------|-----------|--------------------|
| 0    | MORE      | 멀티파트 메시지 계속|
| 1    | CONTROL   | 제어 프레임         |
| 2    | IDENTITY  | 라우팅 ID 포함      |
| 3    | SUBSCRIBE | 구독 요청           |
| 4    | CANCEL    | 구독 취소           |

### 5.5 RAW 프로토콜 프레임 구조

STREAM 소켓 및 외부 클라이언트 연동용 단순 프로토콜입니다.

```
┌──────────────────────┬─────────────────────────────┐
│  Length (4 Bytes)    │     Payload (N Bytes)       │
│  (Big Endian)        │                             │
└──────────────────────┴─────────────────────────────┘
```

- 핸드셰이크 없음 (즉시 데이터 송수신)
- 간단한 구현: `read(4)` -> `read(length)`
- 외부 클라이언트 연동 용이

### 5.6 ZMP 핸드셰이크 시퀀스

```
    Client                              Server
       │                                   │
       │─────── HELLO (greeting) ─────────→│
       │                                   │
       │←────── HELLO (greeting) ──────────│
       │                                   │
       │                                   │  (소켓 타입 호환성 검사)
       │                                   │
       │─────── READY (metadata) ─────────→│
       │                                   │
       │←────── READY (metadata) ──────────│
       │                                   │
       │←─────── Data Exchange ───────────→│
       │                                   │
```

- **HELLO**: 소켓 타입(1B) + Identity 길이(1B) + Identity 값(0-255B)
- **READY**: Socket-Type 속성 (항상), Identity 속성 (DEALER/ROUTER만)

### 5.7 프로토콜-트랜스포트-엔진 매핑

소켓 타입에 따라 엔진이 자동 선택됩니다:

```
┌─────────────────────────────────────────────────────────────────────┐
│                        엔진 선택 규칙                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  소켓 타입 == STREAM ?                                              │
│      ├─ YES → asio_raw_engine_t  (RAW 프로토콜, 핸드셰이크 없음)   │
│      └─ NO  → asio_zmp_engine_t  (ZMP 프로토콜, HELLO/READY)       │
│                                                                     │
│  이 규칙은 모든 트랜스포트(TCP/TLS/IPC/WS/WSS)에서 동일합니다.     │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**전체 매핑 매트릭스**:

| URL 스킴  | Connecter               | Transport          | STREAM 엔진         | 기타 소켓 엔진       | 핸드셰이크        |
|-----------|-------------------------|--------------------|---------------------|---------------------|-------------------|
| `tcp://`  | `asio_tcp_connecter_t`  | `tcp_transport_t`  | `asio_raw_engine_t` | `asio_zmp_engine_t` | (없음) / ZMP      |
| `tls://`  | `asio_tls_connecter_t`  | `ssl_transport_t`  | `asio_raw_engine_t` | `asio_zmp_engine_t` | SSL / SSL+ZMP     |
| `ws://`   | `asio_ws_connecter_t`   | `ws_transport_t`   | `asio_raw_engine_t` | `asio_zmp_engine_t` | WS / WS+ZMP      |
| `wss://`  | `asio_ws_connecter_t`   | `wss_transport_t`  | `asio_raw_engine_t` | `asio_zmp_engine_t` | SSL+WS / SSL+WS+ZMP|
| `ipc://`  | `asio_ipc_connecter_t`  | `ipc_transport_t`  | `asio_raw_engine_t` | `asio_zmp_engine_t` | (없음) / ZMP      |

### 5.8 핸드셰이크 단계 비교

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        핸드셰이크 단계 비교                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  TCP + PAIR/DEALER/ROUTER/PUB/SUB                                      │
│  ┌─────────┐    ┌─────────────┐                                       │
│  │  TCP    │───→│  ZMP        │───→ 데이터 전송                        │
│  │ Connect │    │  Handshake  │                                       │
│  └─────────┘    └─────────────┘                                       │
│                                                                         │
│  TCP + STREAM                                                          │
│  ┌─────────┐                                                           │
│  │  TCP    │───────────────────────→ 데이터 전송 (즉시)                 │
│  │ Connect │                                                           │
│  └─────────┘                                                           │
│                                                                         │
│  TLS + PAIR/DEALER/ROUTER/PUB/SUB                                      │
│  ┌─────────┐    ┌─────────┐    ┌─────────────┐                        │
│  │  TCP    │───→│  SSL    │───→│  ZMP        │───→ 데이터 전송         │
│  │ Connect │    │Handshake│    │  Handshake  │                        │
│  └─────────┘    └─────────┘    └─────────────┘                        │
│                                                                         │
│  WS + PAIR/DEALER/ROUTER/PUB/SUB                                       │
│  ┌─────────┐    ┌─────────┐    ┌─────────────┐                        │
│  │  TCP    │───→│   WS    │───→│  ZMP        │───→ 데이터 전송         │
│  │ Connect │    │ Upgrade │    │  Handshake  │                        │
│  └─────────┘    └─────────┘    └─────────────┘                        │
│                                                                         │
│  WSS + PAIR/DEALER/ROUTER/PUB/SUB                                      │
│  ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────────┐        │
│  │  TCP    │───→│  SSL    │───→│   WS    │───→│  ZMP        │───→ 전송│
│  │ Connect │    │Handshake│    │ Upgrade │    │  Handshake  │        │
│  └─────────┘    └─────────┘    └─────────┘    └─────────────┘        │
│                                                                         │
│  WSS + STREAM                                                          │
│  ┌─────────┐    ┌─────────┐    ┌─────────┐                            │
│  │  TCP    │───→│  SSL    │───→│   WS    │───────────────→ 데이터 전송 │
│  │ Connect │    │Handshake│    │ Upgrade │                            │
│  └─────────┘    └─────────┘    └─────────┘                            │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 5.9 트랜스포트 특성 비교

| 트랜스포트 | 핸드셰이크 | 암호화 | Speculative Write | Gather Write | 용도                    |
|-----------|:----------:|:------:|:-----------------:|:------------:|------------------------|
| TCP       | -          | -      | O                 | O            | 표준 네트워크 통신      |
| IPC       | -          | -      | 옵션              | O            | 로컬 프로세스 간 통신   |
| TLS       | O          | O      | -                 | -            | 암호화된 네트워크 통신  |
| WS        | O          | -      | -                 | O            | 웹 클라이언트 연동      |
| WSS       | O          | O      | -                 | O            | 암호화된 웹 클라이언트  |

---

## 6. 핵심 컴포넌트

### 6.1 msg_t - 메시지 컨테이너

모든 메시지 데이터를 담는 64바이트 고정 크기 구조체입니다.
`malloc` 호출 없이 작은 메시지를 처리할 수 있도록 설계되었습니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                        msg_t (64 bytes)                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │  공통 필드 (base_t)                                        │ │
│  │  - metadata_t* metadata   (8 bytes)                        │ │
│  │  - uint32_t routing_id    (4 bytes)                        │ │
│  │  - group_t group          (16 bytes)                       │ │
│  │  - uint8_t flags          (1 byte)                         │ │
│  │  - uint8_t type           (1 byte)                         │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                                 │
│  유형별 데이터 영역 (union):                                    │
│                                                                 │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │  type_vsm (<=33B on 64-bit)                                │ │
│  │  Very Small Message: 데이터를 msg_t 내부 버퍼에 직접 저장   │ │
│  │  - uint8_t data[max_vsm_size]                              │ │
│  │  - uint8_t size                                            │ │
│  │  -> malloc 없이 인라인 저장, 가장 빠른 경로                 │ │
│  └───────────────────────────────────────────────────────────┘ │
│                            OR                                   │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │  type_lmsg (>33B on 64-bit)                                │ │
│  │  Large Message: 별도 할당된 버퍼 포인터                     │ │
│  │  - content_t* content                                      │ │
│  │    ├── void* data          (데이터 포인터)                  │ │
│  │    ├── size_t size         (크기)                           │ │
│  │    ├── msg_free_fn* ffn    (해제 함수)                      │ │
│  │    └── atomic_counter_t refcnt (참조 카운트)                │ │
│  └───────────────────────────────────────────────────────────┘ │
│                            OR                                   │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │  type_cmsg: Constant Message (상수 데이터 참조, 해제 불필요)│ │
│  │  type_zclmsg: Zero-copy Large Message (사용자 버퍼 직접 참조)│ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**메시지 플래그**:

| 플래그        | 값   | 설명                                |
|--------------|------|-------------------------------------|
| `more`       | 0x01 | 멀티파트 메시지의 중간 프레임        |
| `command`    | 0x02 | 제어 프레임 (핸드셰이크, 하트비트)  |
| `routing_id` | 0x40 | 라우팅 ID 포함                      |
| `shared`     | 0x80 | 공유 버퍼 (참조 카운팅)             |

**메시지 유형**:

| 유형           | 값  | 설명                                           |
|---------------|-----|------------------------------------------------|
| `type_vsm`    | 101 | Very Small Message (<=33B, 복사 없음)          |
| `type_lmsg`   | 102 | Large Message (malloc'd 버퍼)                  |
| `type_cmsg`   | 104 | Constant Message (상수 데이터 참조)            |
| `type_zclmsg` | 105 | Zero-copy Large Message (사용자 버퍼 직접 사용)|

### 6.2 pipe_t - Lock-Free 메시지 큐

스레드 간 메시지 전달을 위한 양방향 파이프입니다.
Application 스레드와 I/O 스레드 사이에서 `msg_t`를 Lock-free로 교환합니다.

```
┌───────────────────────────────────────────────────────────────┐
│                          pipe_t                               │
├───────────────────────────────────────────────────────────────┤
│                                                               │
│  Thread A (Socket)              Thread B (I/O)                │
│       │                              │                        │
│       │    ┌──────────────────┐     │                        │
│       ├───→│   _out_pipe      │────→│  (송신: Socket -> I/O) │
│       │    │   (YPipe<msg_t>) │     │                        │
│       │    └──────────────────┘     │                        │
│       │                              │                        │
│       │    ┌──────────────────┐     │                        │
│       │←───│   _in_pipe       │←────┤  (수신: I/O -> Socket) │
│       │    │   (YPipe<msg_t>) │     │                        │
│       │    └──────────────────┘     │                        │
│                                                               │
│  High Water Mark (HWM): 메시지 큐 크기 제한                   │
│  - _hwm: 아웃바운드 HWM (큐 초과 시 송신 차단)               │
│  - _lwm: 인바운드 Low Water Mark (HWM의 절반, 재개 기준)     │
│                                                               │
└───────────────────────────────────────────────────────────────┘
```

**YPipe 특성**:
- Lock-free FIFO 큐 (CAS 연산 기반)
- 캐시 라인 최적화
- 메모리 배리어를 통한 가시성 보장

**파이프 상태 머신**:

```
                    ┌────────────┐
                    │   active   │ <────────────────┐
                    └─────┬──────┘                  │
                          │ receive delimiter       │ connect
                          v                         │
              ┌───────────────────────┐             │
              │ delimiter_received    │             │
              └───────────┬───────────┘             │
                          │ send term_ack           │
                          v                         │
              ┌───────────────────────┐             │
              │    term_ack_sent      │             │
              └───────────┬───────────┘             │
                          │ receive term_ack        │
                          v                         │
                    ┌───────────┐                   │
                    │ terminated│ ──────────────────┘
                    └───────────┘     (재연결 시)
```

### 6.3 ctx_t - 컨텍스트

전역 상태를 관리하는 최상위 객체입니다.

**주요 역할**:

1. **I/O 스레드 풀 관리**
   - `zlink_ctx_set(ctx, ZLINK_IO_THREADS, n)`으로 스레드 수 설정 (기본: 1)
   - 각 I/O 스레드는 독립적인 `io_context` 보유
   - 새 연결 시 부하가 가장 적은 I/O 스레드 선택 (affinity 마스크 지원)

2. **소켓 관리**
   - 소켓 생성/삭제 추적
   - 최대 소켓 수 제한 (기본: 1023)
   - 빈 슬롯 재사용

3. **inproc 엔드포인트 관리**
   - `inproc://name` 형식의 주소를 엔드포인트에 매핑
   - 바인드 전 연결 요청을 pending_connections에 보관

```
ctx_t 내부 구조:
┌──────────────────────────────────────────────────────────┐
│  _sockets: array_t<socket_base_t>     활성 소켓 목록     │
│  _empty_slots: vector<uint32_t>       빈 슬롯 재사용     │
│  _io_threads: vector<io_thread_t*>    I/O 스레드 풀      │
│  _slots: vector<i_mailbox*>           스레드 간 메일박스  │
│  _endpoints: map<string, endpoint_t>  inproc 레지스트리   │
│  _pending_connections: multimap       대기 중인 연결       │
│                                                          │
│  _max_sockets: int     (기본: 1023)                      │
│  _io_thread_count: int (기본: 1)                         │
│  _max_msgsz: int       (최대 메시지 크기)                │
└──────────────────────────────────────────────────────────┘
```

### 6.4 session_base_t - 세션

소켓과 엔진 사이의 브리지 역할을 합니다.

```
┌─────────────────────────────────────────────────────────────┐
│                     session_base_t                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌──────────────┐    ┌─────────┐    ┌─────────────────┐   │
│  │ socket_base_t│←──→│ pipe_t  │←──→│ asio_engine_t   │   │
│  │              │    │         │    │                 │   │
│  │  zlink_send() │    │ YPipe   │    │ async_read/     │   │
│  │  zlink_recv() │    │         │    │ async_write     │   │
│  └──────────────┘    └─────────┘    └─────────────────┘   │
│                                                             │
│  push_msg(): 엔진 -> 세션 -> 파이프 -> 소켓                │
│  pull_msg(): 소켓 -> 파이프 -> 세션 -> 엔진                │
│                                                             │
│  추가 역할:                                                 │
│  - 연결 상태 관리                                           │
│  - 재연결 로직 (지수 백오프)                                │
│  - Connecter 선택 (URL 스킴에 따라)                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 6.5 스레딩 모델

```
┌─────────────────────────────────────────────────────────────────┐
│                    zlink Threading Model                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                 Application Threads                      │   │
│  │  - zlink_send() / zlink_recv() 호출                      │   │
│  │  - 소켓별로 하나의 스레드에서만 접근 권장                │   │
│  │  - 여러 소켓은 여러 스레드에서 사용 가능                 │   │
│  └──────────────────────────┬──────────────────────────────┘   │
│                              │                                  │
│                   Lock-free Pipes (YPipe)                       │
│                              │                                  │
│  ┌──────────────────────────v──────────────────────────────┐   │
│  │                    I/O Threads                           │   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐                │   │
│  │  │ Thread 0 │ │ Thread 1 │ │ Thread N │  (설정 가능)    │   │
│  │  │io_context│ │io_context│ │io_context│                │   │
│  │  └──────────┘ └──────────┘ └──────────┘                │   │
│  │                                                          │   │
│  │  - 비동기 I/O 처리 (Proactor 패턴)                      │   │
│  │  - 인코더/디코더 실행                                    │   │
│  │  - 네트워크 송수신                                       │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    Reaper Thread                         │   │
│  │  - 종료된 소켓/세션 자원 정리                             │   │
│  │  - 지연된 삭제 처리                                      │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**스레드 간 통신 (Mailbox 시스템)**:

```
Application Thread              I/O Thread
      │                              │
      │  zlink_send()                 │
      │      │                       │
      │      v                       │
      │  [msg_t를 YPipe에 push]      │
      │      │                       │
      │  mailbox.send(activate_write)│
      │─────────────────────────────→│
      │                              │  (신호 수신)
      │                              │
      │                              v
      │                         [YPipe에서 msg_t pop]
      │                              │
      │                         [인코딩 및 전송]
```

- 각 스레드는 자신만의 `mailbox_t`를 보유합니다.
- `mailbox_t`는 내부적으로 `ypipe_t<command_t>`와 `signaler_t`로 구성됩니다.
- 명령 타입: `stop`, `plug`, `attach`, `bind`, `activate_read`, `activate_write` 등

---

## 7. 데이터 흐름

### 7.1 메시지 송신 (Outbound / Tx)

```
┌───────────────────────────────────────────────────────────────────┐
│                    APPLICATION THREAD                             │
├───────────────────────────────────────────────────────────────────┤
│                                                                   │
│  (1) zlink_send(socket, data, size, flags)                        │
│       │                                                           │
│       v                                                           │
│  (2) socket_base_t::send()                                       │
│       │  - msg_t 생성 (VSM 또는 LMSG)                             │
│       │  - 소켓 타입별 라우팅 전략 선택                            │
│       │    . DEALER: lb_t (Round-robin)                          │
│       │    . ROUTER: ID 기반 직접 라우팅                          │
│       │    . PUB: dist_t (모든 구독자에게 전송)                   │
│       v                                                           │
│  (3) pipe_t::write()                                             │
│       │  - YPipe에 메시지 푸시 (Lock-free)                        │
│       │  - HWM 체크 (초과 시 차단 또는 드롭)                     │
│       v                                                           │
│  (4) mailbox signal to I/O thread                                │
│                                                                   │
└───────────────────────────────────────────────────────────────────┘
                              │
                              v
┌───────────────────────────────────────────────────────────────────┐
│                      I/O THREAD                                   │
├───────────────────────────────────────────────────────────────────┤
│                                                                   │
│  (5) asio_engine_t: activate_write 이벤트 수신                    │
│       │                                                           │
│       v                                                           │
│  (6) pull_msg_from_session()                                     │
│       │  - 파이프에서 메시지 읽기                                  │
│       v                                                           │
│  (7) encoder: 메시지 -> 바이트 스트림                              │
│       │  - ZMP: 8바이트 헤더 + 페이로드                           │
│       │  - RAW: 4바이트 길이 + 페이로드                           │
│       v                                                           │
│  (8) speculative_write() 시도                                    │
│       │  - 성공: 즉시 동기 쓰기 완료                               │
│       │  - 실패 (EAGAIN): async_write_some() 스케줄              │
│       v                                                           │
│  (9) transport: 네트워크 전송                                     │
│       - TCP: 직접 전송                                            │
│       - TLS: SSL 암호화 후 전송                                   │
│       - WS: Beast WebSocket 프레이밍 후 전송                      │
│                                                                   │
└───────────────────────────────────────────────────────────────────┘
```

### 7.2 메시지 수신 (Inbound / Rx)

```
┌───────────────────────────────────────────────────────────────────┐
│                      I/O THREAD                                   │
├───────────────────────────────────────────────────────────────────┤
│                                                                   │
│  (1) async_read_some() 완료 콜백                                  │
│       │  - 네트워크에서 바이트 수신                                │
│       v                                                           │
│  (2) on_read_complete()                                          │
│       │                                                           │
│       v                                                           │
│  (3) decoder: 바이트 스트림 -> 메시지                              │
│       │  - 헤더 파싱 (ZMP 8B / RAW 4B)                            │
│       │  - 페이로드 크기 확인                                      │
│       │  - msg_t 생성                                             │
│       v                                                           │
│  (4) push_msg_to_session()                                       │
│       │                                                           │
│       v                                                           │
│  (5) session_base_t::push_msg()                                  │
│       │  - 메시지 검증                                            │
│       │  - 인바운드 파이프로 전달                                  │
│       v                                                           │
│  (6) pipe_t::write() (인바운드 파이프)                            │
│       │  - YPipe에 메시지 푸시                                    │
│       v                                                           │
│  (7) 소켓에 읽기 가능 신호 (activate_read)                        │
│                                                                   │
└───────────────────────────────────────────────────────────────────┘
                              │
                              v
┌───────────────────────────────────────────────────────────────────┐
│                    APPLICATION THREAD                             │
├───────────────────────────────────────────────────────────────────┤
│                                                                   │
│  (8) zlink_recv(socket, buffer, size, flags)                      │
│       │                                                           │
│       v                                                           │
│  (9) socket_base_t::recv()                                       │
│       │  - 소켓 타입별 수신 전략                                   │
│       │    . DEALER/SUB: fq_t (Fair Queueing)                    │
│       │    . ROUTER: Routing ID 추출 후 메시지 전달              │
│       │  - 토픽 필터링 (SUB)                                      │
│       v                                                           │
│  (10) pipe_t::read()                                             │
│        │  - YPipe에서 메시지 팝 (Lock-free)                      │
│        v                                                          │
│  (11) 사용자 버퍼로 데이터 복사                                   │
│                                                                   │
└───────────────────────────────────────────────────────────────────┘
```

### 7.3 연결 수립 흐름 (Connection Establishment)

```
┌───────────────────────────────────────────────────────────────────┐
│                     연결 수립 단계                                 │
├───────────────────────────────────────────────────────────────────┤
│                                                                   │
│  zlink_connect("tcp://host:port")                                 │
│       │                                                           │
│       v                                                           │
│  (1) address_t 파싱                                               │
│       │  - 프로토콜 식별 (tcp, tls, ws, wss, ipc)                │
│       │  - 주소/포트 추출                                         │
│       v                                                           │
│  (2) session_base_t 생성                                         │
│       │  - 재연결 정책 설정                                       │
│       v                                                           │
│  (3) connecter 생성 및 시작                                       │
│       │  - URL 스킴에 따라 connecter 클래스 선택                 │
│       │  - async_connect() 호출                                   │
│       v                                                           │
│  (4) TCP 연결 완료 (3-way handshake)                              │
│       │                                                           │
│       v                                                           │
│  (5) [TLS/WSS] 트랜스포트 핸드셰이크                              │
│       │  - TLS: SSL_do_handshake()                               │
│       │  - WS: HTTP Upgrade 요청/응답                            │
│       v                                                           │
│  (6) Engine 생성 및 plug()                                       │
│       │  - 소켓 타입에 따라 asio_zmp_engine_t 또는               │
│       │    asio_raw_engine_t 선택                                 │
│       v                                                           │
│  (7) [ZMP] 프로토콜 핸드셰이크                                    │
│       │  - HELLO 교환 (소켓 타입, Identity)                      │
│       │  - 소켓 타입 호환성 검사                                   │
│       │  - READY 교환 (메타데이터)                                │
│       v                                                           │
│  (8) engine_ready()                                              │
│       - pipe 생성 및 연결                                         │
│       - start_input() / start_output()                            │
│       -> 데이터 송수신 가능                                       │
│                                                                   │
└───────────────────────────────────────────────────────────────────┘
```

---

## 8. 소스 트리 구조

```
core/
├── include/                         # 공용 헤더 (zlink.h)
│
├── src/
│   ├── api/                         # Public C API
│   │   ├── zlink.cpp                # 모든 zlink_* 함수 진입점
│   │   └── zlink_utils.cpp          # 유틸리티 함수
│   │
│   ├── core/                        # 시스템 기반 컴포넌트
│   │   ├── ctx.cpp/hpp              # 컨텍스트 (스레드풀, 소켓 관리)
│   │   ├── msg.cpp/hpp              # 메시지 컨테이너 (64B 고정)
│   │   ├── pipe.cpp/hpp             # Lock-free 양방향 파이프
│   │   ├── session_base.cpp/hpp     # 소켓-엔진 브리지
│   │   ├── io_thread.cpp/hpp        # I/O 워커 스레드
│   │   ├── mailbox.cpp/hpp          # 스레드 간 명령 전달
│   │   ├── object.cpp/hpp           # 기반 객체 (명령 처리)
│   │   ├── own.cpp/hpp              # 소유 관계 관리
│   │   ├── reaper.cpp/hpp           # 종료 자원 정리
│   │   ├── signaler.cpp/hpp         # 스레드 깨우기 신호
│   │   ├── options.cpp/hpp          # 소켓 옵션 저장소
│   │   ├── address.cpp/hpp          # 주소 파싱
│   │   ├── endpoint.cpp/hpp         # 엔드포인트 관리
│   │   ├── command.hpp              # 스레드간 명령 정의
│   │   ├── socket_poller.cpp/hpp    # 소켓 폴러
│   │   └── ...
│   │
│   ├── sockets/                     # 소켓 타입 구현
│   │   ├── socket_base.cpp/hpp      # 모든 소켓의 기반 클래스
│   │   ├── pair.cpp/hpp             # PAIR 소켓
│   │   ├── dealer.cpp/hpp           # DEALER 소켓
│   │   ├── router.cpp/hpp           # ROUTER 소켓
│   │   ├── pub.cpp/hpp              # PUB 소켓
│   │   ├── sub.cpp/hpp              # SUB 소켓
│   │   ├── xpub.cpp/hpp             # XPUB 소켓
│   │   ├── xsub.cpp/hpp             # XSUB 소켓
│   │   ├── stream.cpp/hpp           # STREAM 소켓
│   │   ├── lb.cpp/hpp               # 로드 밸런서 (Round-robin)
│   │   ├── fq.cpp/hpp               # 공정 큐 (Fair Queueing)
│   │   ├── dist.cpp/hpp             # 배포자 (Fan-out)
│   │   └── proxy.cpp/hpp            # 프록시 유틸리티
│   │
│   ├── engine/                      # I/O 엔진
│   │   ├── i_engine.hpp             # 엔진 인터페이스
│   │   └── asio/
│   │       ├── asio_engine.cpp/hpp       # 기반 Proactor 엔진
│   │       ├── asio_zmp_engine.cpp/hpp   # ZMP 프로토콜 엔진
│   │       ├── asio_raw_engine.cpp/hpp   # RAW 프로토콜 엔진
│   │       ├── asio_poller.cpp/hpp       # io_context 래퍼
│   │       ├── i_asio_transport.hpp      # 트랜스포트 인터페이스
│   │       ├── handler_allocator.hpp     # 핸들러 메모리 관리
│   │       └── asio_error_handler.hpp    # 에러 핸들링
│   │
│   ├── protocol/                    # 프로토콜 인코딩/디코딩
│   │   ├── zmp_protocol.hpp         # ZMP v2.0 상수 정의
│   │   ├── zmp_encoder.cpp/hpp      # ZMP 인코더
│   │   ├── zmp_decoder.cpp/hpp      # ZMP 디코더
│   │   ├── zmp_metadata.hpp         # ZMP 메타데이터
│   │   ├── raw_encoder.cpp/hpp      # RAW (Length-Prefix) 인코더
│   │   ├── raw_decoder.cpp/hpp      # RAW 디코더
│   │   ├── encoder.hpp              # 인코더 기반 템플릿
│   │   ├── decoder.hpp              # 디코더 기반 템플릿
│   │   ├── i_encoder.hpp            # 인코더 인터페이스
│   │   ├── i_decoder.hpp            # 디코더 인터페이스
│   │   ├── metadata.cpp/hpp         # 메타데이터 처리
│   │   ├── wire.hpp                 # 바이트 순서 변환
│   │   └── decoder_allocators.cpp/hpp # 디코더 메모리 관리
│   │
│   ├── transports/                  # 트랜스포트 구현
│   │   ├── tcp/                     # TCP 트랜스포트
│   │   │   ├── tcp_transport.cpp/hpp
│   │   │   ├── asio_tcp_connecter.cpp/hpp
│   │   │   ├── asio_tcp_listener.cpp/hpp
│   │   │   ├── tcp_address.cpp/hpp
│   │   │   └── tcp.cpp/hpp
│   │   │
│   │   ├── ipc/                     # IPC 트랜스포트 (Unix 전용)
│   │   │   ├── ipc_transport.cpp/hpp
│   │   │   ├── asio_ipc_connecter.cpp/hpp
│   │   │   ├── asio_ipc_listener.cpp/hpp
│   │   │   └── ipc_address.cpp/hpp
│   │   │
│   │   ├── ws/                      # WebSocket 트랜스포트 (Beast)
│   │   │   ├── ws_transport.cpp/hpp
│   │   │   ├── asio_ws_connecter.cpp/hpp
│   │   │   ├── asio_ws_listener.cpp/hpp
│   │   │   ├── asio_ws_engine.cpp/hpp   # (미사용, asio_zmp/raw_engine 사용)
│   │   │   └── ws_address.cpp/hpp
│   │   │
│   │   └── tls/                     # TLS/SSL 트랜스포트 (OpenSSL)
│   │       ├── ssl_transport.cpp/hpp
│   │       ├── wss_transport.cpp/hpp
│   │       ├── asio_tls_connecter.cpp/hpp
│   │       ├── asio_tls_listener.cpp/hpp
│   │       ├── ssl_context_helper.cpp/hpp
│   │       └── wss_address.cpp/hpp
│   │
│   ├── services/                    # 고수준 서비스
│   │   ├── common/                  # 공통 서비스 유틸리티
│   │   │   ├── heartbeat.hpp
│   │   │   ├── service_key.hpp
│   │   │   └── service_types.hpp
│   │   ├── discovery/               # 서비스 디스커버리
│   │   │   ├── discovery.cpp/hpp
│   │   │   ├── discovery_protocol.hpp
│   │   │   └── registry.cpp/hpp
│   │   ├── gateway/                 # 게이트웨이
│   │   │   ├── gateway.cpp/hpp
│   │   │   ├── receiver.cpp/hpp
│   │   │   └── routing_id_utils.hpp
│   │   └── spot/                    # SPOT 서비스
│   │       ├── spot_pub.cpp/hpp     # 발행 핸들 (thread-safe)
│   │       ├── spot_sub.cpp/hpp     # 구독/수신 핸들
│   │       └── spot_node.cpp/hpp    # 네트워크 제어 (PUB/SUB mesh)
│   │
│   └── utils/                       # 유틸리티
│       ├── ypipe.hpp                # Lock-free 파이프
│       ├── yqueue.hpp               # Lock-free 큐
│       ├── atomic_counter.hpp       # 원자적 카운터
│       ├── atomic_ptr.hpp           # 원자적 포인터
│       ├── blob.hpp                 # 바이너리 블롭
│       ├── clock.cpp/hpp            # 시간 측정
│       ├── random.cpp/hpp           # 난수 생성
│       ├── ip_resolver.cpp/hpp      # IP 주소 해석
│       ├── mtrie.cpp/hpp            # 멀티 트라이 (XPUB 구독)
│       ├── trie.cpp/hpp             # 트라이
│       ├── radix_tree.cpp/hpp       # 래딕스 트리 (XSUB 구독)
│       ├── generic_mtrie.hpp        # 제네릭 멀티 트라이 템플릿
│       ├── mutex.hpp                # 뮤텍스 래퍼
│       ├── condition_variable.hpp   # 조건 변수 래퍼
│       ├── err.cpp/hpp              # 에러 핸들링
│       ├── ip.cpp/hpp               # IP 유틸리티
│       ├── config.hpp               # 컴파일 설정
│       └── ...
│
├── tests/                           # 기능 테스트
└── unittests/                       # 내부 단위 테스트
```

---

## 부록

### A. 관련 문서

- [ZMP v2.0 프로토콜 상세](protocol-zmp.md)
- [RAW 프로토콜 상세](protocol-raw.md)
- [STREAM 소켓 WS/WSS 최적화](stream-socket.md)
- [스레딩 및 동시성 모델](threading-model.md)
- [성능 특성 및 튜닝 가이드](../guide/10-performance.md)

### B. 핵심 인터페이스 요약

**i_asio_transport** (모든 트랜스포트의 공통 인터페이스):

```
i_asio_transport
  +-- open(io_context, fd)              연결 열기
  +-- close()                           연결 닫기
  +-- async_read_some(buffer, handler)  비동기 읽기
  +-- async_write_some(buffer, handler) 비동기 쓰기
  +-- read_some(buffer, size)           동기(추측적) 읽기
  +-- write_some(buffer, size)          동기(추측적) 쓰기
  +-- requires_handshake()              핸드셰이크 필요 여부
  +-- async_handshake(type, handler)    비동기 핸드셰이크
  +-- is_encrypted()                    암호화 여부
  +-- supports_speculative_write()      추측적 쓰기 지원 여부
  +-- supports_gather_write()           Gather 쓰기 지원 여부
```

**i_engine** (엔진 인터페이스):

```
i_engine
  +-- plug(session)                     세션에 연결
  +-- terminate()                       종료
  +-- restart_input()                   수신 재시작
  +-- restart_output()                  송신 재시작
```

### C. 성능 최적화 기법 요약

| 기법                | 설명                                                            |
|--------------------|-----------------------------------------------------------------|
| Speculative I/O    | 비동기 호출 전 동기 I/O를 먼저 시도하여 콜백 오버헤드 제거       |
| Gather Write       | writev()로 헤더+바디를 시스템 콜 1회로 전송                     |
| Zero-Copy Message  | msg_t에 사용자 버퍼 포인터만 저장, 복사 없이 전송               |
| VSM (Inline)       | 33바이트 이하 메시지는 msg_t 내부 버퍼에 직접 저장 (malloc 없음)|
| Lock-free YPipe    | CAS 연산 기반 스레드 간 메시지 교환, 뮤텍스 없음               |
| Cache Line 최적화  | YPipe 노드를 캐시 라인 크기에 맞춰 배치                         |
| Backpressure       | 10MB 한도 초과 시 읽기 중단으로 메모리 폭주 방지                |
